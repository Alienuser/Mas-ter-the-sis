\section{Umsetzung}
Das Architekturbild~\ref{fig:umsetzung_frontendarchitektur_4} auf Seite~\pageref{fig:umsetzung_frontendarchitektur_4}
zeigt die Architektur des Frontends und die Kommunikation mit dem API Connect Service. Dabei sollen sowohl das Frontend
als auch die Smartphone-Apps mit dem API Gateway kommunizieren, um die Anfragen zu vereinheitlichen.

Ein Cloud Foundry-Container wird mit einem Node.js-Boilerplate versehen. Mit Hilfe des Boilerplates lassen sich
Node.js-Applikationen innerhalb des Containerts verwalten und nutzen. Es stellt eine Runtime zur Verfügung, in welcher
das Frontend laufen kann.

Die Smartphone-Apps werden auf Basis von Android und auch iOS entwickelt. Beide Systeme erhalten innerhalb der App ein
WebView-Layout, welche für das Laden und das Darstellen der Webseite zuständig ist. Damit ist es einfach, eine schon
erstellte, responsive Webseite optimal für ein Smartphone zu nutzen. Zusätzlich können Feinheiten wie angepasste Layouts
der einzelnen Systeme übernommen werden.

Die Kommunikation zwischen Frontend und API Connect sowie zwischen den entwickelten Smartphone-Apps und dem API Connect
Service laufen über REST-Aufrufe (englisch REST-Calls).

Da in den Smartphone-Apps lediglich das schon geschriebene Frontend geladen wird, müssen die Aufrufe nur ein Mal
spezifiziert und umgesetzt werden.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/architektur_frontend.pdf}
    \caption{Übersicht der Zielarchitektur}
    \label{fig:umsetzung_frontendarchitektur_4}
\end{figure}

\subsection{Web-Frontend}
\label{subsec:webseite}
Als nächstes kann man das Web-Frontend (auch Webseite oder englisch website oder auch client genannt) entwickeln. Um
nicht mit zahlreiche Iterationen und Anpassungen bei der Entwicklung zu kämpfen, empfiehlt es sich mit der Definition
von Use-Cases -- also mit der Definition der Aktionen eines Endnutzers auf der Webseite -- zu beginnen.

Anschließend sollte man für die einzelnen Use-Cases Mockups erstellen, die aufzeigen, wie ein Endnutzer die einzelnen
Aktionen durchführen kann. In einem weiteren Schritt setzt der Entwickler die gebauten Mockups dann in Quellcode um,
damit ein Prototyp enstehen kann. Diesen könnte man dann mit einer ausgewählten Gruppe testen.

Damit die Benutzung der Webseite von verschiedenen Endgeräten aus möglich ist, muss man sich im Weiteren gedanken über
das Thema \textit{Responsive} machen. Wie sich die gebaute Webseite also auf den verschiedenen Displaygrößen anpasst.

Nachdem man die Webseite dann fertig entwickelt hat, muss man sie noch in einen Container installieren. Dies ist über
mehrere Varianten möglich. Auch kann man zusätzliche Erweiterungen einbauen, welche das Arbeiten mit der Webseite
erleichtern oder speziellen Bedürfnissen der Endanwender gerecht wird.

\subsubsection{Use-Cases}
Als Use-Case kommt zum jetzigen Zeitpunkt lediglich eine Aktion in Frage. Das Erstellen von Vorhersagen für die
manuell eingetragenen Parameter der Maschine.

Da das Backend mit seinem neuronalen Netz aktuell nicht mehr berechnen kann, ist der angegebene Use-Case auch der einzig
sinnvolle.

Nachdem der Endnutzer die Parameter dann in das Formular eingetragen hat, soll er die Möglichkeit bekommen, die
resultierenden Vorhersagen zu erhalten, um diese an der Maschine zu testen. Eine Fortschrittsanzeige soll darüber
informieren, dass das System arbeitet.

Da der Use-Case relativ einfach definiert werden konnte, kann man als nächstes mit der Erstellung der Mockups beginnen,
um eine erste Idee der Anwendung und ihrem Aussehen zu bekommen.

\subsubsection{Mockups erstellen}
Da der Use-Case nun definiert ist, kann man mit der Entwicklung der Mockups beginnen. Dabei ist die Wahl des Designs auf
eine zweispaltige Startseite gefallen. Eine der beiden Spalten beinhlatet die Eingabewerte und die andere Spalte
beinhaltet die vorhergesagten Argumente, welche von dem neuronalen Netz bestimmt werden.

In Abbildung~~\ref{fig:umsetzung_mockup_scale_1} auf Seite~\pageref{fig:umsetzung_mockup_scale_1} zeigt eine erste
Version des Frontends zur Umsetzung der beiden Spalten. Dabei werden in der linken Spalte die Werte in Formularfelder
eingetragen und in der rechten Spalte die vorhergesagten Parameter angezeigt.

Im mittleren Bereich der Seite soll ein Button erscheinen, welcher durch betätigen die eingetragenen Parameter an das
Backend schickt und anschließend den Output anzeigt.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/mockup_scale_1.png}
    \caption{Erstes Mockup für das Dashboard}
    \label{fig:umsetzung_mockup_scale_1}
\end{figure}

Damit man sowohl der Input als auch der Output verbessert anzeigen kann ist es sinnvoll, die beiden Spalten noch weiter
zu unterteilen. Gerade bei den Eingabewerten gibt es zahlreiche Parameter, die in Gruppen zusammengefügt werden können.

So ist es zum Beispiel möglich die Parameter \textit{Produktbreite}, \textit{Produkthöhe} und \textit{Produkttiefe} zu
einer Gruppe namens \textit{Produktmaße} zusammenzufügen.

Die Abbildung~\ref{fig:umsetzung_mockup_scale_2} auf Seite~\pageref{fig:umsetzung_mockup_scale_2} zeigt das angepasste
Mockup mit seinen Gruppen sowohl auf der Input"~ als auch der Output-Seite.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/mockup_scale_2.png}
    \caption{Überarbeitetes Mockup für das Dashboard}
    \label{fig:umsetzung_mockup_scale_2}
\end{figure}

Im oberen Bereich der Anwendung kann man ein Logo der Anwendung erscheinen lassen und nebenan den Namen für die aktuell
geöffnete Seite.

Damit man das Frontend auch für weitere Maschinen oder Maschinenkomponenten anpassen kann, kann der Entwickler ein Menü
hinzufügen, über das man auf die anderen Seiten mit Eingabe"~ und Ausgabewerte zugreifen kann.

Dieses Menü entwickelt man am Besten so, dass es sich aus dem linken Bereich herausschiebt und über ein
\textit{Hamburger-Menü-Icon}\footnote{https://de.wikipedia.org/wiki/Hamburger-Menü-Icon} zu öffnen ist.

So ist in Abbildung~\ref{fig:umsetzung_mockup_scale_menu} auf Seite~\pageref{fig:umsetzung_mockup_scale_menu} das Mockup
für ein seitliches Menü zu sehen, welches über drei beispielhafte Menüeinträge verfügt.

Das Menü soll sich beim aufklappen über den Inhalt legen und den restlichen Bildschirm etwas ausgrauen, sodass für den
Nutzer ersichtlich ist, dass aktuell am Menü eine Auswahl getroffen werden muss.

Ein Klick in den ausgegrauten Bereich, oder auch auf einen der Menüpunkte, schließt das Menü allerdings wieder, sodass
der Nutzer immer das tun kann, was er gerade möchte.

Die Auswahl eines neuen Menüpunktes hat außerdem zur Folge, dass sich die vorher angesprochene Überschrift im oberen
Bereich der Webseite mit dem Namen des Menüpunktes füllt, damit der Nutzer immer genau weiß, unter welchem Menüpunkt
er sich aktuell befindet.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/mockup_scale_menu.png}
    \caption{Mockup für die Navigation}
    \label{fig:umsetzung_mockup_scale_menu}
\end{figure}

\subsubsection{Gedanken zu Responsive}
Damit das Frontend auch von einem Smartphone aus bedient und eine WebView-App dafür geschrieben werden kann, muss die
Webseite auf verschiedene Displaygrößen so reagieren können, damit es alle Informationen nutzerfreundlich anzeigt. Dabei
dürfen keine wichtigen Informationen verschwinden oder die Interaktion mit dem System eingeschränkt sein.

Um dieser Anforderung gerecht zu werden, muss das Frontend mit responsiven Eigenschaften versehen werden. Da die
Webseite in Ihrer ursprünglichen Idee zwei Spalten hat, ist es für die responsive Version interessant, die Spalten nicht
nebeneinander anzuzeigen, sondern untereinander. Dies aber auch nur, sofern es nicht genügend Platz hat, um beide
Spalten nebeneinander anzuzeigen.

Bei größeren Displays wäre es im horizontalen Modus (englisch landscape mode) möglich, beide Spalten auch nebeneinander
anzuzeigen. Wohingegen im vertikalen Modus (englisch portrait mode) immer Sinnvoll ist, die beiden Spalten untereinander
anzuzeigen.

Das Mockup in Abbildung~\ref{fig:umsetzung_mockup_scale_responsive} auf Seite~\pageref{fig:umsetzung_mockup_scale_responsive}
zeigt die Darstellung des Frontends auf einem Smartphone im vertikalen Modus. Dabei ist die Spalte mit der
\textit{Eingabe} aktuell sichtbar und unterhalb wird der Button für die Berechnung der Ausgabeparameter angezeigt.

Unter dem Button ist die Spalte für die Ausgabeparameter angesiedelt, welche erst erscheint, wenn Vorhersagen zur
Verfügung stehen. So ist der Scrollbalken auf der Webseite nicht unnötig lang um den Endnutzer nicht zu verunsichern.

Auch wird nach der Bestätigung des Buttons automatisch zum Bereich der Ausgabe gescrollt, damit dies nicht manuell
geschehen muss.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.45]{images/kapitel_4/mockup_scale_responsive.png}
    \caption{Mockup des responsiven Designs}
    \label{fig:umsetzung_mockup_scale_responsive}
\end{figure}

\subsubsection{Webseite umsetzen}
Da die Mockups für die Anwendung fertig umgesetzt sind, kann im Weitern damit begonnen werden, das Frontend wirklich
umzusetzen. Da man das Frontend mit Angular umsetzt und die Angular-CLI installiert ist, kann man auf dem
Entwicklerrechner mit dem folgenden Befehl eine neue Angular-Seite einrichten.

\begin{lstlisting}[language=bash, caption=Einrichten einer neuen Angular-Seite, label=ls:umsetzung_angular]
    ng new dashboard
\end{lstlisting}

Dabei wird ein neuer Ordner mit dem Namen \textit{dashboard} angelegt, welcher alle benötigten Ordner und Dateien um
eine funktionierende Angular-Seite zu bauen beinhaltet. Wenn man anschließend in den neu erstellen Ordner wechselt, kann
man mit dem folgenden Befehl die Standard-Applikation von Angular bauen lassen und sie im Browser ansehen.

\begin{lstlisting}[language=bash, caption=Bereitstellen der Angular-Webseite, label=ls:umsetzung_angularserve]
    ng serve --open
\end{lstlisting}

Der Browser öffnet sich automatisch und zeigt die Standardanwendung. Darin ist ein großes Bild des Angular-Logos mit
einer großen Überschrift und ein paar weiteren Kommentaren zu sehen.

Jegliche Änderung am Quellcode der aktuellen Anwendung hat zur Folge, dass die entsprechende Angular-Komponente neu
gebaut und der Browser neu geladen wird um die Änderung direkt sichtbar zu machen.

Nun kann damit begonnen werden, die Webseite entsprechend der Mockups umzusetzen. Dabei ist darauf zu achten, die
Standard-Komponenten der Angular-Material-Bibliothek zu nutzen, damit das Erscheinungsbild der Anwendung einer Android-
App ähnelt.

Die Komponenten sind auf der entsprechenden Dokumentationsseite\footnote{https://material.angular.io/components/categories}
einsehbar und man kann sie von da aus direkt kopiert um sie im eigenen Quellcode zu nutzen. Auch Icons und vorgefertigte
Farben kann man der Webseite entnehmen um eine im Stil passende Webseite zu bauen.

In Abbildung~\ref{fig:umsetzung_website_input} auf Seite~\pageref{fig:umsetzung_website_input} ist die fertige
umgesetzte Webseite zu sehen, welche die Parameter für das neuronale Netz eingeben kann. Die linke Spalte mit der
\textit{Eingabe} ist also umgesetzt.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/website_input.png}
    \caption{Umsetzung der Webseite mit Eingabe-Spalte}
    \label{fig:umsetzung_website_input}
\end{figure}

Nun kann man die zweite Spalte mit der \textit{Ausgabe} anfertigen um sie in dem noch leeren Platz zu positionieren. Die
Umsetzung ist dabei gleich der Umsetzung mit der linken Spalte.

In der Abbildung~\ref{fig:umsetzung_website_output} auf Seite~\pageref{fig:umsetzung_website_output} ist die komplette
Webseite zu sehen mit beiden Spalten und dem Button zur generierung der Vorhersage.

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/website_output.png}
    \caption{Umsetzung der Webseite mit Ausgabe-Spalte}
    \label{fig:umsetzung_website_output}
\end{figure}

Bei der Umsetzung ist entscheidend, dass die rechte Spalte des Dashboards nur dann angezeigt wird, wenn auch die Abfrage
an das Backend durch ist und Vorhersagen an das Frontend zurück gekommen sind. Allerdings sollte man die Überschrift
der Spalte anzeigen -- Ausgabe -- damit der Endnutzer weiß, dass da noch weitere Informationen
folgen werden.

Auch ist so ersichtlich, dass der Platz auf der rechten Seite nicht verschwendet wird. Wenn die Eingabe der Parameter
sich über die gesamte Seite ziehen würde und nach betätigung des Buttons dann verkleinert, würde das zu viel bewegung in
der Webseite nach sich ziehen. Das wirkt sich negativ auf das verständnis der Webseite aus.

Die einzelnen Blöcke der Ausgabe erscheinen nach und nach durch kleine Animationen, welche die einzelnen Boxen langsam
einblendet. Dadurch kann man Zeit gewinnen, um das JSON-Objekt, welches vom Backend zurück kommt, zu parsen. Die einzelnen
Werte muss man sich aus dem großen Array herausziehen.

Das Parsen kann zeitgleich mit der Animation starten. So wird de Endnutzer symbolisiert, dass die Daten schon da sind
und sie auch gleich sichtbar sind. So muss er nicht noch das Parsing abwarten.

Dies erleichtert die Arbeit mit der Webseite enorm, da der Endnutzer nicht direkt mit vielen Boxen konfrontiert wird.
Außerdem existieren für die rechte Spalte nach dem öffnen der Seite auch noch keine Daten die angezeigt werden könnten.
So macht eine Darstellung des Bereiches auch keinen Sinn.

Damit der Endnutzer sich schneller auf der Webseite zurecht finden kann, ist die Platzierung von kleinen Icons und
Beschreibungstexten an den verschiedenen Boxen sinnvoll. So weiß der Nutzer direkt, was er in welcher Box machen oder
auch Einstellen kann.

Sinnvoll ist es auch die Parameter der linken Spalte mit passenden Zufallszahlen zu versehen. So kann der Nutzer direkt
nach dem öffnen der Seite eine Vorhersage starten um die Funktionsfähigkeit der Webseite und des Backends zu testen.
Auch kann er so nachvollziehen, welche Werte er in der linken Spalte eintragen muss, falls er sich zuanfang noch
unsicher ist.

Als nächsten Schritt muss man die Anpassung der Webseite an einen kleineren Bildschirm machen. Die Darstellung kann den
Mockups entnommen werden. Da die beiden Spalten (Eingabe und Ausgabe) in jeweils einer eigenen Angular-Komponente
entwickelt sind, kann man diese in eine \textit{CSS-FlexBox} packen.

Damit ist es möglich zu definieren, wie sich die einzelnen \textit{FelxBoxen} verhalten, wenn der Platz nicht
ausreichend ist. Dabei gibt man an, dass die Boxen sich im normalen Fall nebeneinander befinden. Falls dann der Platz
nicht ausreicht, sollen sie sich untereinander anordnen.

Dabei ist wichtig, dass der Button in der Mitte auch eine FlexBox erhält, damit dieser bei kleinem Platz auch
umgebrochen werden kann. Die Umbrechnung übernimmt die Bibliothek automatisch und es bedarf keiner weiteren
Konfiguration.

Ein Test mit einem mobilen Browser oder den Dev-Tools des Explorers \textit{Chrome} oder auch \textit{FireFox} zeigt die
Abbildung~\ref{fig:umsetzung_website_smartphone} auf Seite~\pageref{fig:umsetzung_website_smartphone}. Es ist lediglich
die \textit{Eingabe}-Spalte zu sehen.

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.13]{images/kapitel_4/website_smartphone.jpg}
    \caption{Umsetzung der Webseite mit responiven Fähigkeiten}
    \label{fig:umsetzung_website_smartphone}
\end{figure}

Bei der Eingabe der einzlenen Formularfelder scrollt man unweigerlich nach unten. Am Ende der Eingabe erscheint dann der
Button zum erstellen der Vorhersage für die Parameter.

Nach einem Klick auf diesen Button und einer kurzen Ladeanimation erscheint die Ansicht der Ausgabe. Der Nutzer muss
nicht mehr nach unten scrollen.

Auch in der mobilen Version steht die Überschrift für die Ausgabe schon am unteren Rand, damit der Endnutzer weiß, dass
die Informationen unterhalb der Eingabe kommen werden und er nicht unnötig überrascht wird.

\subsubsection{Erweiterungen}
Die Webseite ist fertig entwickelt. Nun kann man sich über Erweiterungen Gedanken machen, die den Endnutzer bei der
Eingabe der Daten unterstützen können.

Für zahlreiche Erweiterungen, welche im folgenden Behandelt werden, spielt der \textit{Service Worker} eine
entscheidende Rolle. Dieser installiert, definiert über ein Manifest, mittels JavaScript-Technologie einen Proxy
zwischen dem Webbrowser und dem Server.

Damit kann man die Grundlage für Push-Benachrichtigungen, progressive Web-Apps (PWA), offline Modus und komplexer
Cache-Strategie setzen.

Um in der erstellten Angular-Anwendung einen Service-Worker zu installieren, benötigt man eine zusätzliche Bibliothek,
welche die interne Arbeit übernimmt. Diese kann man mittels des folgenden Befehls in die Anwendung einbauen.

\begin{lstlisting}[language=bash, caption=Hinzufügen der PWA-Bibliothek, label=ls:umsetzung_angularaddpwa]
    ng add @angular/pwa
\end{lstlisting}

Nun muss man den ServiceWorker in der \textit{angular.json}-Datei aktivieren. Dazu fügt man die Zeile
\textit{"serviceWorker": true} in das erste \textit{apps}-Objekt ein.

Mit der Aktivierung der Funktionalität wird beim Bau der Anwendung eine \textit{Angular Service Worker}-Datei mit dem
Namen \textit{ngsw-worker.js} angelegt. Außerdem wird eine Konfigurationsdatei für den Service Worker mit dem Namen
\textit{ngsw.json} angelegt.

Die erste Datei übernimmt die Installation, das Aktualisieren und das Deinstallieren des Service Workers in den Browser.
Die zweite Datei kann den Service Worker konfigurieren. So kann man dort zum Beispiel definieren, wie der Service Worker
heißt und welches Icon für ihn angezeigt werden soll.

Die Einrichtung des Service Workers ist damit abgeschlossen. Allerdings funktioniert dieser nur, wenn die
Angular-Anwendung produktiv gebaut wird (\textit{ng build --prod}) und dann über das Protokoll \textit{https} aufgerufen
wird.

Wenn man im Nachgang die Webseite aufruft (mehr dazu im Kapitel~\ref{toolchain_einrichten} auf
Seite~\pageref{toolchain_einrichten}), kann man den Service Worker in den \textit{Entwicklertools} über den Menüpunkt
\texttt{Applikation} und dann \texttt{Service Worker} sehen. Dort kann man ihn auch zur Aktualisierung zwingen und
Löschen.

\subsubsection{Offline Mode}
Da man im vorangegangenen Kapitel den Service Worker installiert und eingerichtet hat, kann man als nächstes eine der
grundlegensten Funktionen des Service Workers nutzen -- das Caching mit offline Modus.

Damit man diesen umsetzen kann, muss man lediglich die Datei \textit{ngsw.json} anpassen und um alle cachbaren Elemente
erweitern.

In Anhang~\ref{sec:serviceWorkerConfig} auf Seite~\pageref{sec:serviceWorkerConfig} ist die komplette
Konfigurationsdatei angegeben. Diese kann man komplett nutzen. Nachdem man die Angular-Anwendung wieder gebaut hat, kann
man sie aufrufen und alle Elemente werden automatisch im Browser gecached.

Wenn man im Anschluss die Internetverbindung unterbricht (offline Modus oder Netzwerk trennen) und die Webseite
aktualisiert, wird sie trotzdem wie gewünscht angezeigt. Allerdings kann man in diesem Fall keine Vorhersagen tätigen,
da die REST-Schnittstelle nicht aufgerufen werden kann.

Der offline Modus funktioniert auf allen Plattformen in allen Browsern. So kann man diesen sowohl auf dem Desktop-Computer
nutzen als auch auf dem Smartphone oder Tablet.

\subsubsection{Keine offline Anfragen}
Damit man im offline Modus nicht auf einen Fehler stößt, wenn man eine Abfrage an das Backend machen möchte, soll im
Weiteren das Frontend auf die verschiedenen Modi (online oder offline) reagieren können.

Beispielhaft soll man sich folgendes Szenario vor Augen führen. Ein Endnutzer öffnet bei aktiver Internetverbindung die
Webseite um eine Vorhersage zu tätigen. Damit er die geforderten Eingabeparameter allerdings eingeben kann, muss er zur
betreffenden Maschine und diese auslesen.

In dem Raum in dem sich die Maschine befindet gibt es allerdings keine WLAN Verbindung, worauf die Webseite in den
offline Modus geht. Nachdem der Endnutzer die Daten eingetragen hat und eine Vorhersage starten will, würde er einfach
eine Fehlermeldung bekommen, dass das Backend nicht angefragt werden kann. Eventuell würden seine Eingaben auch
verschwinden, da er versucht die Seite neu zu laden.

Um dieses Problem zu beheben, soll das Frontent im offline Modus gar keine Anfragen an das Backend machen sondern den
Nutzer informieren, dass es aktuell im offline Modus ist. Damit weiß der Nutzer, dass er aktiv nach einer
Internetverbindung suchen muss.

Um dies zu bewerkstelligen muss man einen Service in die Angular-Anwendung einbauen, welcher immer über den aktuellen
Modus (online oder offline) bescheid weiß und bei einer Änderung allen Komponenten bescheid gibt.

Mit dem folgenden Befehl kann man einen neuen Service in die Anwendung einbauen.

\begin{lstlisting}[language=bash, caption=Hinzufügen eines Services, label=ls:umsetzung_angularaddservice]
    ng generate service network
\end{lstlisting}

Dieser Befehl legt eine Datei mit dem Namen \textit{network.service.ts} an, in der der Service definiert wird. Die
Implementierung der geforderten Funktion ist relativ einfach, da Angular von Haus aus viele Funktionalitäten mitbringt.

So kann man mit dem in Listing~\ref{ls:umsetzung_angularservicenetwork} auf
Seite~\pageref{ls:umsetzung_angularservicenetwork} definierten Quellcode ein \textit{Observable} anlegen, welches den
aktuellen Netzwerkmodus beinhaltet. Sollte dieser sich ändern, werden alle \textit{Observer} darüber informiert.

\begin{lstlisting}[language=JavaScript, caption=Funktion des Network-Services, label=ls:umsetzung_angularservicenetwork]
    public isConnected = true;

    constructor(private connectionService: ConnectionService) {
        this.connectionService.monitor().subscribe(isConnected => {
            this.isConnected = isConnected;
        })
    }
\end{lstlisting}

Anschließend kann man bei jeder Anfrage an das Backend das in Listing~\ref{ls:umsetzung_angularchecknetwork} auf
Seite~\pageref{ls:umsetzung_angularchecknetwork} definierte If-Statement nutzen, um zu überprüfen ob aktuell eine
Internetverbindung vorliegt oder nicht. Falls nicht, sollte man den Nutzer über einen gut sichtbaren Hinweis darüber
informieren, dass aktuell keine Abfrage möglich ist.

\begin{lstlisting}[language=JavaScript, caption=Überprüfung ob eine Internetverbindung vorliegt, label=ls:umsetzung_angularchecknetwork]
    if (this.networkService.isConnected) {
        ...
    } else {
        ...
    }
\end{lstlisting}

Auch wäre es möglich einen dauerhaften Hinweis einzublenden, wenn keine Internetverbindung vorliegt. Dies müsste man dann
in der \textit{app.component.ts} Datei global machen. Dabei ist entscheidend, dass das nicht mit einem If-Statement
möglich ist.

Mit einer Snackbar kann man den entsprechenden Hinweis optimal anzeigen und positionieren lassen.

%% TODO noch schreiben
\subsubsection{Toolchain einrichten}
Im letzten Schritt bei der Entwicklung des Frontends muss man die Toolchain einrichten, damit man den geschriebenen
Quellcode auch in einem Cloud Foundry Container in der Cloud installieren kann.

Dabei ist die konfiguration der Pipeline nicht so einfach wie beim Erstellen des TensorFlow-Containers, da man die
Angular-Anwendung bauen muss, bevor man sie in den Container schieben kann. Auch ist der gebaute Quellcode in einem
anderen Ordner als der Teil, welchen man in das Git-Repository lädt.

So sind nacheinander wenige Schritte notwendig, damit man die gebaute Anwendung auch richtig in den Container schieben
kann.

In einem ersten Schritt muss man die Toolchain jedoch erst anlegen.

\colorbox{yellow}{Hier fehlt was}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/toolchain_pipeline.png}
    \caption{Übersicht der Toolchain-Konfiguration}
    \label{fig:umsetzung_toolchain_pipeline_frontend}
\end{figure}

\subsection{Smartphone App}
Da das Frontend (Dashboard) nun fertig entwickelt ist, kann man es im nächsten Schritt für die Umsetzung der
Smartphone-App nutzen.

Die Umsetzung der Smartphone-App erfolgt auf Basis von Android und iOS. Dies hat den Vorteil, dass ein größerer
potentieller Kundenkreis gewonnen werden kann, da diese beiden Systeme die mobilen Betriebssysteme
dominieren~\cite{online_umsetzung_mobileos}.

In den zwei weiteren Kapiteln werden die Umsetzungen für die beiden Betriebssysteme erläutert. Insbesondere wird auf die
technischen Unterschiede der Systeme eingegangen.

%% TODO noch schreiben
\subsubsection{Android}
Bauen und erstellen der Apps

\colorbox{yellow}{Hier fehlt was}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{images/kapitel_4/android_folder.png}
    \caption{Ordner und Dateien in Android Studio}
    \label{fig:umsetzung_android_folder}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.1]{images/kapitel_4/android_app.png}
    \caption{Android-App im Smartphone-Emulator}
    \label{fig:umsetzung_android_app}
\end{figure}

%% TODO noch schreiben
\subsubsection{iOS}
Bauen und erstellen der Apps

\colorbox{yellow}{Hier fehlt was}

\begin{figure}[h]
    \centering
    \includegraphics[width=\textwidth]{images/kapitel_4/ios_ide.png}
    \caption{Übersicht von xCode}
    \label{fig:umsetzung_ios_ide}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.7]{images/kapitel_4/ios_folder.png}
    \caption{Ordner und Dateien in xCode}
    \label{fig:umsetzung_ios_folder}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[scale=0.4]{images/kapitel_4/ios_app.png}
    \caption{iOS-App im Smartphone-Emulator}
    \label{fig:umsetzung_ios_app}
\end{figure}